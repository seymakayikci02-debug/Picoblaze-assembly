
;test cases
load s0,0	;register to help square loop function
load s1,8	;xcenter circle center
load s2,9	;ycenter circle center
load s3,0	;x1 rectangle
load s4,0	;y1 rectangle
load s5,1	;x2 rectangle
load s6,2	;y2 rectangle
load s7,3	;radius
;;;;;;

;test cases
wrmem s0,00	;register to help square loop function
wrmem s1,01	;xcenter circle center
wrmem s2,02	;ycenter circle center
wrmem s3,03	;x1 rectangle
wrmem s4,04	;y1 rectangle
wrmem s5,05	;x2 rectangle
wrmem s6,06	;y2 rectangle
wrmem s7,07	;radius
;;;;;;

COMP s3,s5				;;x1 and x2 comparison
JUMP c,lower_part

lower_part:
	
	
	COMP s3,s5			;;x1 x2 comparison if its equal go to right side hence you finished lower part
	JUMP z,right_part
	CALL square_loop_x  ;;taking square of subtraction of x values and storing into s3
	CALL square_loop_y  ;;taking square of subtraction of x values and storing into s3
	CALL square_loop_r_r
	ADD s8,s9
	COMP s8,sA
	JUMP c,cross
	
	rdmem s3, 03         ; s1 = RAM[10]
	ADD  s3, 1           ; s1 = s1 + 1
	rdmem s0,00	;register to help square loop function
	rdmem s1,01	;xcenter circle center
	rdmem s2,02	;ycenter circle center
	wrmem s3,03	;x1 rectangle
	rdmem s4,04	;y1 rectangle
	rdmem s5,05	;x2 rectangle
	rdmem s6,06	;y2 rectangle
	rdmem s7,07	;radius
	ADD sB,1	;counter for x side
	JUMP lower_part


right_part:
	
	
	COMP s4,s6			;;y1 y2 comparison if its equal go to upper side hence you finished right part
	JUMP z,upper_part
	CALL square_loop_x  ;;taking square of subtraction of x values and storing into s3
	CALL square_loop_y  ;;taking square of subtraction of x values and storing into s3
	CALL square_loop_r_r
	ADD s8,s9
	COMP s8,sA
	JUMP c,cross
	rdmem s4, 04         ; s1 = RAM[10]
	ADD  s4, 1           ; s1 = s1 + 1
	rdmem s0,00	;register to help square loop function
	rdmem s1,01	;xcenter circle center
	rdmem s2,02	;ycenter circle center
	wrmem s4,04	;x1 rectangle
	rdmem s3,03	;y1 rectangle
	rdmem s5,05	;x2 rectangle
	rdmem s6,06	;y2 rectangle
	rdmem s7,07	;radius
	ADD sC,1	;counter for x side
	JUMP right_part


upper_part:	
	

	CALL square_loop_x  ;;taking square of subtraction of x values and storing into s3
	CALL square_loop_y  ;;taking square of subtraction of x values and storing into s3
	CALL square_loop_r_r
	ADD s8,s9
	COMP s8,sA
	JUMP c,cross
	rdmem s3, 03         ; s1 = RAM[10]
	SUB  s3, 1           ; s1 = s1 + 1
	rdmem s0,00	;register to help square loop function
	rdmem s1,01	;xcenter circle center
	rdmem s2,02	;ycenter circle center
	wrmem s3,03	;x1 rectangle
	rdmem s4,04	;y1 rectangle
	rdmem s5,05	;x2 rectangle
	rdmem s6,06	;y2 rectangle
	rdmem s7,07	;radius
	SUB  sB, 1       ; counter -= 1
	;COMP  sB, 0
	JUMP Z,left_part
	JUMP upper_part


left_part:	
	

	CALL square_loop_x  ;;taking square of subtraction of x values and storing into s3
	CALL square_loop_y  ;;taking square of subtraction of x values and storing into s3
	CALL square_loop_r_r
	ADD s8,s9
	COMP s8,sA
	JUMP c,cross
	rdmem s4, 04         ; s1 = RAM[10]
	SUB  s4, 1           ; s1 = s1 + 1
	rdmem s0,00	;register to help square loop function
	rdmem s1,01	;xcenter circle center
	rdmem s2,02	;ycenter circle center
	wrmem s4,04	;x1 rectangle
	rdmem s3,03	;y1 rectangle
	rdmem s5,05	;x2 rectangle
	rdmem s6,06	;y2 rectangle
	rdmem s7,07	;radius
	SUB  sC, 1       ; counter -= 1
	;COMP  sC, 0
	JUMP Z,circle_inside_rec
	JUMP left_part



circle_inside_rec:	
	

	CALL square_loop_x  ;;taking square of subtraction of x values and storing into s3
	CALL square_loop_y  ;;taking square of subtraction of x values and storing into s3
	CALL square_loop_r_r
	ADD s8,s9
	COMP s8,sA
	JUMP c,cross
	rdmem s4, 04         ; s1 = RAM[10]
	SUB  s4, 1           ; s1 = s1 + 1
	rdmem s0,00	;register to help square loop function
	rdmem s1,01	;xcenter circle center
	rdmem s2,02	;ycenter circle center
	wrmem s4,04	;x1 rectangle
	rdmem s3,03	;y1 rectangle
	rdmem s5,05	;x2 rectangle
	rdmem s6,06	;y2 rectangle
	rdmem s7,07	;radius
	SUB  sC, 1       ; counter -= 1
	;COMP  sC, 0
	JUMP Z,done
	JUMP left_part


	
square_loop_x:
	SUB s3,s1
	
	TEST s3, 128     ; does s1 have MSB = 1?
	CALL NZ, negative_x
	TEST s3, 128
	CALL Z, positive_x
    RET
    
	negative_x:
		XOR  s3, 255        ; invert bits (FFh = 255 dec)
		ADD  s3, 1          ; +1
	    CALL square_loop_x_x
		RET 

	positive_x:
		CALL square_loop_x_x
		RET
	; else positive
	
	; squares value in s3
; result -> s8

	square_loop_x_x:
	    LOAD s0, s3      ; counter = s3
	    LOAD s8, 0       ; result = 0
	
	square_loop_inside_x:
	    ADD  s8, s3      ; result += s3
	    SUB  s0, 1       ; counter -= 1
	    JUMP NZ, square_loop_inside_x
	    RET
	
	

square_loop_y:
	SUB s4,s2
	
	TEST s4, 128     ; does s1 have MSB = 1?
	CALL NZ, negative_y
	TEST s4, 128
	CALL Z, positive_y
	RET
	
	negative_y:
		XOR  s4, 255        ; invert bits (FFh = 255 dec)
		ADD  s4, 1          ; +1
	    CALL square_loop_y_y
		RET 
	
	positive_y:
		CALL square_loop_y_y
		RET
	; else positive
	
	square_loop_y_y:
	    LOAD s0, s4      ; counter = s3
	    LOAD s9, 0       ; result = 0
	
	square_loop_inside_y:
	    ADD  s9, s4      ; result += s3
	    SUB  s0, 1       ; counter -= 1
	    JUMP NZ, square_loop_inside_y
	    RET
	    
square_loop_r_r:
	    LOAD s0, s7      ; counter = s3
	    LOAD sA, 0       ; result = 0
	
	square_loop_inside_r:
	    ADD  sA, s7      ; result += s3
	    SUB  s0, 1       ; counter -= 1
	    JUMP NZ, square_loop_inside_r
	    RET	    
	
cross:
	WRMEM s3,08
	WRMEM s4,09
JUMP done

done:
	JUMP done
;left_part:
;		JUMP left_part
		
